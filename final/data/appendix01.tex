%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../main"
%%% End: 

\chapter{外文资料书面翻译}

\begin{center}
RadixVM: Scalable address spaces for multithreaded applications
\end{center}

\section{摘要}

RadixVM是一个新的虚拟内存管理系统(Virtual
Memory)的设计，使得在硬件保证Cache一致性的多核计算机系统上，多线程程序共享地址空间操作可以完全并发地经行。现在，大多数操作系统中mmap和munmap都是串行经行，这迫使程序员把他们的多线程程序分割成多个多进程程序，或者保留分配后的内存以避免返回这些内存到操作系统造成的额外性能损耗。RadixVM系统通过保证对不重叠虚拟地址空间操作的完全可扩展性，把开发者从这些繁杂的优化任务中解脱出来。

RadixVM结合了如下三种新技术：1、通过基数树（radix
tree）而不是平衡树来管理VMA结构，避免不必要的Cache
line冲突；2，使用新的，节省内存的分布式引用计数技术；3，使用新的远程TLB无效化（TLB
shootdown）策略，避免不必要的核间通信。
我们在80核的机器上经行了实验，发现RadixVM系统在非重叠虚拟内存区域中达到了完美可扩展。换言之，如果多个线程并行地地经行mmap和munmap系统调用，这些调用可以完全独立运行，并且不会带来Cache一致性协议造成的多核通讯流量。


\section{介绍}
在多核处理器系统上，多线程程序的性能瓶颈可能会发生操作系统中虚拟内存子系统的锁竞争上。虚拟内存子系统为了保证数据结构的复杂一致性，多数被广泛使用的内核，例如Linux和FreeBSD，都对每个共享地址空间（进程的VMA结构）加上了一把大锁。
近年来的研究已经发现了一些让缺页处理程序（page fault
handler）和mmap/munmap系统调用（用于从操作系统分配和释放内存）并行执行的方法。但是，如果mmap和munmap操作涉及的虚拟地址空间不重叠（例如内存分配和释放的场景下），理论上这些系统调用可以完美地并行化。这篇文章主要贡献就是在虚拟内存子系统中达到了这个目标。

一个传统的虚拟内存子系统支持三种关键操作：mmap用于向进程的VMA中加入一个区域，munmap用于删除一段区域，pagefault用于在缺页时根据VMA向硬件页表中插入记录，并在必要时分配物理页。这篇文章主要面向这样的一类用户程序：使用多线程模型在同一个VMA中频繁地并发发起上述几种操作。多线程内存访问频繁的程序最匹配这种模式：mmap、munmap和相关变形通常是高性能内存分配器和垃圾回收器实现的核心调用。频繁对文件经行映射和删除映射的用户程序也为操作系统内核的内存子系统产生压力，适合本文的应用场景。

因为操作系统及时对非重叠内存区域也会串行化mmap和munmap的调用，这类应用程序的瓶颈很容易发生在操作系统内核中。作为结果，用户程序开发者通常使用一些技巧绕开虚拟内存子系统造成的瓶颈。多线程内存分配器提供了很多这样的技巧：它们通常为每个线程向操作系统申请一大块内存，或延后munmap调用，或根本不返回内存到操作系统。有的程序提供一个内核可加载模块实现自定义的VM操作以提高分配器的性能。这些技巧都有各自的限制。

很多时候使用这些技巧已经足够避开OS内部VM的瓶颈，但通常有若干缺点。例如，一个Google工程师告诉我们，由于munmap的多核扩展性问题Google使用的内存分配器不精确地向OS返回内存。这样造成用户程序在退出前占用数GB的内存。这会延迟其他程序的启动甚至造成服务器使用效率低。其他公司的工程师也向我们反映相似问题。

随着系统CPU核数的增加，我们相信这些技巧会越来越复杂，并且缺点会越来越明显。
因此，我们的文章着眼与解决VM可扩展性问题的根源。我们的文章将提出一种新的虚拟内存管理子系统设计，它只在VM操作包含重叠区域时才会出现竞争现象。这保证了两个线程在操作不同的VM区域时，操作系统不会造成性能瓶颈，因此上述的技巧也不需要。在这种情况下，虚拟内存操作随着核心数线性扩展。如果应用程序使用多线程操作同一VM区域，两个线程之间共享竞争是不可避免的，但本系统可以限制使用的共享内存区域CPU核心。

为了达到并发的mmap/munmap操作，在虚拟内存系统的设计过程中存在几个挑战。
第一，虚拟内存系统不同部分之间维护着十分复杂的数据结构。例如，当munmap一个内存区域时，内核需要保证在回收物理页前删除硬件页表中的记录。否则，同一进程的其他线程可能会访问到其他进程的内存页面。为了保证内核正确实现这些操作的语义，内核必须保证一系列操作的顺序，这可能会在多核系统上造成性能瓶颈。
第二、即使是单个被多核竞争的Cache
line也可能成为多核系统的性能瓶颈。我们的一个原始设计是使用无锁可并发跳表（skip
list），但是跳表的内部节点会造成Cache Line竞争，限制了它的多核可扩展性。
第三、TLB无效化。为了保证没有CPU核心缓存过期的地址映射，CPU必须通过核间通信保证TLB一致性。第四、很多VM设计使用较为直接的方法避免VM锁的竞争，但是带来很大的内存代价。

本文提出了一个称为RadixVM的新设计。RadixVM使用三个不同的组件来使VM操作对非重叠内存区域具有完美可扩展性。
第一、我们设计了radix tree数据结构来记录虚拟内存映射。
第二、使用新的可扩展性引用计数来对共享物理页进行计数。
第三、但一个页面被unmap时，我们避免不必要的TLB无效化。
这三项措施使得我们的RadixVM系统具有极好的多核可扩展性。

我们在一个新的研究用内核xv6上实现了RadixVM，因为对Linux的虚拟内存系统做修改需要很大的工作量（Linux的VM子系统与其他子系统具有很强耦合性）。我们在80核的机器上测试了我们的系统，使用了Mosbench中的多线程的MapReduce库。单元测试测试显示我们的RadixVM系统达到了很好的可扩展性。

在xv6上，而不是Linux上实现RadixVM的一个缺点是xv6无法运行复杂的大型应用，如Oracle的Java虚拟机中的垃圾回收器。另一方面，RadixVM面临着一个蛋鸡问题：很多VM受限应用已经使用一些技巧来避免传统VM系统的扩展性问题。作为结果，我们的实验使用微型测例来做测试。


\section{设计}
实现不同进程中的可扩展的VM操作很容易，因为每个进程涉及到不同的VMA结构。RadixVM的设计是新颖的，因为它允许同一进程的多个线程同时执行mmap/munmap或缺页的操作（对非重叠的内存区域）。也就是说，如果在同一进程中的n个线程分配内存，这些mmaps是完美可扩展的（每次操作花费同样的时间，不论n多大）。同样，如果一个线程在一个CPU核上分配内存，同一进程中的另一个线程在另一CPU核操作系统返回不同的内存区域，那么这些操作不减慢或干扰对方的任何的mmap操作。最后，如果一个CPU核心上正在运行访问缺页处理例程，而其他CPU核进行VM操作（不包括pagefault)，RadixVM也能达到完美可扩展性。另一方面，如果使用mmap和munmap对重叠内存区域进行操作，或者一个线程在mmaped或munmaped的页面上发生缺页，RadixVM将串行化那些操作。这种设计的可扩展性，可以容易地被应用程序开发人员了解和利用：应用程序只需要简单地避免对重叠内存区域并发操作。

为了在现代多核计算机实现完美的可扩展性，RadixVM努力确保CPU核不发生任何Cache
Line竞争。在现代的Cache一致性的硬件上，任何争用的Cache
Line的行为都可能是一个造成可扩展性问题的风险，因为频繁写入的多核共享的Cache
Line时，其他CPU核必须重新读取Cache内容，这种访问通常在Cache
Line的主节点上被串行化。

本节介绍RadixVM如何达到非重叠区域的VM操作的完美可扩展。首先，我们提出三个关键数据结构，然后介绍如何使用这些数据结构来实现标准的VM操作。

\subsection{使用Refcache来进行引用计数}
引用计数在很多操作系统中都非常关键，对RadixVM也一样，因为两个VM区域可能共享相同的物理页。例如Fork新进程时，RadixVM必须通过引用计数来计算需要释放的物理页。要做到这一点。RadixVM引用计数每一个物理页。但简单的引用计数器可能会导致可扩展性问题。因为多个线程将在计数变量上竞争。同样，RadixVM需要使用引用计数对Radix
tree的节点确定它们何时为空。

此的部分介绍Refcache，一种新型的引用计数方案。RadixVM使用Refcache来跟踪和回收的物理内存页面和基数树节点。Refcache实现高效空间的、懒惰的、可扩展的引用计数
--
每个CPU核有一个引用变化量缓存。Refcache针对可以容忍一定程度的延迟，且资源回收、递增和递减操作经常会发生在相同的核心的应用（例如，在同一个线程在发生pagefault的内存区域也unmap映射区域）。

Refcache与现有可扩展性的引用计数机制相比，需要的空间和需要引用计数的对象的数目加上CPU核心数，而不是其积成正比，每个CPU核心可以通过调整Delta的大小来在空间和可扩展性上做平衡。这点非常重要的，当一个大型的多核VM子系统需要在大CPU核数上跟踪每一个物理页，传统的可扩展的引用计数器将需要超过物理内存的一半来跟踪余下的物理内存。

Refcache缓存递增和递减操作并批量处理，这减少Cache
Line的竞争，同时提供一个可调的时间控制当其引用计数下降到零后，对象被垃圾回收的延迟。但一个对象只在单核上修改不会发生Cache
Line竞争，而Refcache自身只需要以恒定速率修改Cache Line来维护全局状态。

\textbf{基本Refcache}
在Refcache中，每个引用计数的对象都包含一个全局计数器，每个核维护一个本地固定大小的缓存，用来保存本CPU核上的计数增量。计数的增减只对本地增量Cache进行修改，本地CPU
Cache定时被刷新到对象的全局引用计数中。真正的计数值一般是未知的，但我们假设，一旦它下降到零，它会保持为零（在弱引用的情况下，我们将在后面讨论）。
Refcache依赖于真实计数为零后一直稳定到零的性质。

\subsection{Radix tree}
本质上，一个地址空间是一个从虚拟地址到元数据和物理内存的映射。为了完美地实现可扩展的非重叠的地址空间操作，RadixVM需要一个数据结构，可以跟踪此映射和支持mmaping和munmaping，同时避免不相交的虚拟内存区域上的VM操作之间的争。

避免竞争的一个方法是避免共享。例如，开发者定义把地址空间静态地分配到各个CPU核上，每个核各自管理自己的地址空间。这种方法保证了非重叠内存区域上的元数据访问不会发生冲突。这种方法的缺点在于它复杂化了数据共享，并且需要应用开发者感知这种划分。一个更好的解决方法是使用一些共享的数据结构，它允许多个线程对称地管理共享内存地址区域，这也是现在所有VM子系统的做法。

特别地，支持无锁操作的数据结构，如Bonsai树的读操作似乎是有可行的，因为它避免了由于锁导致的Cache
Line竞争。然而，无锁定操作，并不意味着没有Cache
Line竞争。例如，对于插入和查询操作，无锁的并发Skip
list可能会导致在涉及不同的节点上查找和插入键出现Cache
Line竞争，因为保持$O(\log
N)$查找节点的数据复杂度。插入操作必须修改内部节点。正如我们将在后面所述，该读写共享造成严重的扩展性问题，因为更多的CPU核需要重写读取被修改的Cache
Line，及时这些修改与它自身无关。

任何平衡树或类似的数据结构受到这种的Cache
Line竞争影响。一种解决方案（完全不切实际）是代表用一个线性数组来存储进程的虚拟内存映射的元数据，
对每个虚拟页面，单独在一个大线性数组上进行虚拟页号索引。在这种线性表示下，mmap/munmap，缺页的无锁地进行。
在非重叠的内存区的VM操作将访问的线性数组的不相交部分，从而达到完美多核可扩展。在本节中提出的设计遵循相似的设计思路，但实际使用一个多层次压缩的基数树大大降低内存消耗。

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\textwidth]{figures/appedix_radixvm.png} 
  \caption*{图：基数树包含一个匿名映射映射。蓝色表示使用36位的虚页号进行查找的路径。树的最后一级为每个页面包含单独的映射元数据。}
\end{figure}

RadixVM索引数据结构类似于一个硬件页表，映射元数据存储在一个固定的深度的基数树，树的每个级别的索引由9个（或更少）的虚页号位（如图）索引。和一维数组一样，基数树只支持点查询（非范围查询）和迭代，但不像数组，RadixVM可以压缩重复的记录，
并懒惰地分配基数树的节点。从逻辑上讲，任何具有相同值的节点，将完全折叠成一个单一的记录存储在父节点中。这变形持续到树的根节点，大片的未使用的虚拟地址空间被表示成空节点，因此大范围设置为相同的值非常迅速。这种折叠在只需要很小的代价：迫使radix
tree扩展的mmap的操作可能导致多核的竞争，即使它们设计的区域不重叠。然而，这样的冲突是罕见的。

为了记录每个映射，RadixVM为每个页面映射范围的每个页面，在radix
tree中单独存储元数据。这不同于典型的设计，它们分配一个单一的元数据对象来代表一个映射（例如，在Linux的VMA结构体）。存储元数据每一页的单独副本，使在RadixVM存储的元数据相对较小，并消除共享的对象，避免mmap或munmap调用拆分或合并元数据对象，消除共享竞争。此外，映射元数据对象的设计，使最初的每一页的初始元数据对一个映射都是相同的，这意味着大的映射可以有效地创建并折成少数的几个基数树的节点。

不像典型的虚拟内存系统设计，RadixVM存储在映射元数据中存储已分配物理内存页面的指针。这在RadixVM是容易做到的，因为除去折叠，每个物理页面有一个单独的映射元数据对象。同样重要的是有这个数据结构有利于RadixVM处理TLB
shootdown。而起渐近意义下，基数树所需的空间，并不会多于硬件页表，这意味着硬件页表本身是可以被丢弃的且操作系统可以释放其内存。

为了限制基数树的内存占用，操作系统必须能够释放不再包含任何有效的映射元数据节点。为了完成这项任务，在不产生竞争的情况下，我们利用Refcache来跟踪在每个节点的引用数目。当这个计数下降到零，基数树可以从树中删除节点。

坍塌radix
tree需要引入额外的竞争，但是与饥渴的垃圾回收方案相比，快速修改映射不能造成树节点的快速删除和重建。因为一个节点必须在两个epoch以后才被真正释放，因此节点删除和重建的成本被分摊。

对比传统的平衡树，用基数树管理VM元数据允许RadixVM在非重叠地址空间范围上的并行操作，以达到完美的可扩展性。这可能造成一个潜在的更大的内存开销的成本，然而，地址空间布局往往表现出良好的局部性，并有效地压缩大的地址范围，使基数树非常适合使用在VM子系统上。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{TLB shootdown}

实现多核可扩展mmap或munmap操作的难点之一是每个CPU核的硬件页转换高速缓存(TLB)，页面映射更改需要显式的通知（“TLB
shootdowns”）其他CPU核。因为TLB
shootdowns必须通知每个可能缓存一个被修改的页面映射的CPU，由于硬件并没有提供关于它的CPU可能有缓存一个特定的映射信息，一个保守的设计必须发送TLB
shootdown中断到所有使用相同的地址空间的CPU，这限制了VM系统的可扩展性。

通过跟踪更准确的CPU可能已经访问给定的映射的信息，RadixVM实现mmap和munmap映射元数据的更好的可扩展性。对于由软件填充TLB的体系结构，内核可以使用TLB缺失故障，准确地跟踪哪些CPU拥有一个给定的映射缓存。当以后发生mmap或munmap调用改变这种映射时，RadixVM只需要shootdown访问过这个映射的CPU核。在硬件填充TLB的（如X86）的架构上，通过使用每个核心的使用各自的页表，我们的设计可以达到同样的效果。如果应用程序中的一个线程在一个CPU核上分配，访问，和释放内存，而没有其他线程访问相同的内存区域，RadixVM不好进行TLB shootdown。


这种方法最明显的缺点是需要额外的内存维护每个CPU核的页表。但这个开销是在实际应用程序的总内存占用小。但内存不足时，内核也可以通过共享共享页表或扔掉页表来可以减少开销。


\section{讨论}

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\textwidth]{figures/appedix_pagetable.png} 
  \caption*{图：使用每核单独页表和共享页表的性能对比}
\end{figure}


测试结果显示，RadixVM达到了对非重叠区域上VM操作随着CPU核数增加，完美可扩展的目标。RadixVM使用三种手段优化VM操作。有测试结果可以看出，在单核串行情况下RadixVM和Linux的性能差距在5\%以内，尽管RadixVM没有对单核情况做特殊优化。与预期一样，在多核情况下，RadixVM存储VMA元数据需要Linux两倍左右的内存。存储多核页表需要更多的内存（Metis测例下需要16倍的内存），但两种情况下，操作系统都只占内存总消耗的很小一部分。

\section{结论}
本文提出RadixVM，一个新的虚拟内存的设计，让VM密集型的多线程应用程序的性能可以达到良好的可扩展性。为了实现可扩展性，RadixVM采用三种技术：Radix
tree数据结构，Refcache，有针对性的TLB
shootdown。
使用Metis的MapReduce库和微基准测试例程，获取了一系列常见的虚拟内存使用模式。测试显示，RadixVM实现了其目标。我们希望
RadixVM的设计会激发其他的OS开发者向用户提供可扩展的虚拟内存操作原语，省却应用程序级别的解决方法。

\begin{center}
参考文献
\end{center}
[1]\hspace{15pt}Clements A T, Kaashoek M F, Zeldovich N. RadixVM: Scalable address spaces for multithreaded applications. Proceedings of Proceedings of the ACM EuroSys Conference (EuroSys 2013), Prague, Czech Republic, 2013


\chapter{其它附录}
前面两个附录主要是给本科生做例子。其它附录的内容可以放到这里，当然如果你愿意，可
以把这部分也放到独立的文件中，然后将其 \verb|\input| 到主文件中。
